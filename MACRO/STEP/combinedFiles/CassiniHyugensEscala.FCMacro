# -*- coding: utf-8 -*-
# Cassini–Huygens paramétrico para FreeCAD (Part Workbench)
# Versión endurecida para evitar errores comunes.
# Autor: adaptado para victor0989 (corrección y unificación)

import math
import FreeCAD as App
import Part

try:
    import FreeCADGui as Gui
    HAS_GUI = True
except Exception:
    HAS_GUI = False

# -----------------------
# Parámetros (ajusta según necesites)
# -----------------------
SCALE = 1.0
DEBUG_SEPARATE = True  # crea objetos separados para depuración

HGA_DIAM = 4.0
HGA_DEPTH = 0.45
HGA_THK   = 0.020
HGA_HUB_R = 0.25
BUS_HEIGHT = 1.8
BUS_FLAT2FLAT = 2.0
BUS_TOP_TO_HGA = 0.3

RTG_RADIUS = 0.20
RTG_LENGTH = 3.2
RTG_BOOM_LEN = 1.8
RTG_BOOM_R = 0.05

LGA_DIAM = 0.5
LGA_DEPTH = 0.07
LGA_THK = 0.006

MAG_BOOM_LEN = 11.0
MAG_BOOM_R = 0.03

HUY_DIAM = 2.7
HUY_THK_CENTER = 0.60
HUY_OFFSET_FROM_BUS = 0.4

TOL = 1e-7

# -----------------------
# Utilidades robustas
# -----------------------

def unique_points(points, tol=TOL):
    out = []
    for p in points:
        keep = True
        for q in out:
            if (p - q).Length <= tol:
                keep = False
                break
        if keep:
            out.append(p)
    return out

def make_closed_wire(points):
    pts = list(points)
    pts = unique_points(pts)
    if len(pts) < 3:
        raise ValueError("Se requieren al menos 3 puntos únicos para un wire cerrado (got %d)." % len(pts))
    if (pts[0] - pts[-1]).Length > TOL:
        pts.append(pts[0])
    try:
        poly = Part.makePolygon(pts)
        w = Part.Wire(poly.Edges)
        if not w.isClosed():
            raise ValueError("Wire no quedó cerrado")
        return w
    except Exception as e:
        edges = []
        for i in range(len(pts)-1):
            edges.append(Part.makeLine(pts[i], pts[i+1]))
        try:
            w = Part.Wire(edges)
            if not w.isClosed():
                edges.append(Part.makeLine(pts[-1], pts[0]))
                w = Part.Wire(edges)
            if not w.isClosed():
                raise ValueError("Wire manual no quedó cerrado")
            return w
        except Exception as e2:
            raise RuntimeError("No se pudo crear wire cerrado: %s | %s" % (e, e2))

def is_wire_planar(wire, tol=TOL):
    verts = [v.Point for v in wire.Vertexes]
    if len(verts) < 3:
        return True
    p0 = verts[0]
    p1 = None
    for i in range(1, len(verts)):
        if (verts[i] - p0).Length > tol:
            p1 = verts[i]
            i1 = i
            break
    if p1 is None:
        return True
    p2 = None
    for j in range(i1+1, len(verts)):
        v01 = p1 - p0
        v02 = verts[j] - p0
        if v01.cross(v02).Length > tol:
            p2 = verts[j]
            break
    if p2 is None:
        return True
    normal = (p1 - p0).cross(p2 - p0)
    nl = normal.Length
    if nl <= tol:
        return True
    normal = App.Vector(normal.x/nl, normal.y/nl, normal.z/nl)
    for v in verts:
        if abs((v - p0).dot(normal)) > 1e-6:
            return False
    return True

def project_points_to_plane(points, plane_point, plane_normal):
    pn = plane_normal
    l = pn.Length
    if l == 0:
        raise ValueError("plane_normal nulo")
    pn = App.Vector(pn.x/l, pn.y/l, pn.z/l)
    out = []
    for p in points:
        v = p - plane_point
        d = v.dot(pn)
        proj = p - pn * d
        out.append(proj)
    return out

def safe_make_face_from_wire(wire):
    if not hasattr(wire, "isClosed"):
        raise ValueError("Se esperaba Part.Wire")
    if not wire.isClosed():
        pts = [v.Point for v in wire.Vertexes]
        wire = make_closed_wire(pts)
    if not is_wire_planar(wire):
        verts = [v.Point for v in wire.Vertexes]
        mean_y = sum([p.y for p in verts]) / len(verts)
        plane_point = App.Vector(0, mean_y, 0)
        plane_normal = App.Vector(0,1,0)
        pts_proj = project_points_to_plane(verts, plane_point, plane_normal)
        pts_proj = unique_points(pts_proj)
        if len(pts_proj) < 3:
            verts_u = unique_points(verts)
            if len(verts_u) < 3:
                raise RuntimeError("Wire degenerado: menos de 3 puntos tras proyección y fallback (len=%d)" % len(verts_u))
            wire = make_closed_wire(verts_u)
        else:
            wire = make_closed_wire(pts_proj)
    try:
        f = Part.Face(wire)
        return f
    except Exception as e:
        pts = [v.Point for v in wire.Vertexes]
        pts = unique_points(pts)
        if len(pts) < 3:
            raise RuntimeError("No se pudo crear Face: wire con menos de 3 puntos (len=%d)" % len(pts))
        if (pts[0] - pts[-1]).Length > TOL:
            pts.append(pts[0])
        poly = Part.makePolygon(pts)
        f = Part.Face(poly)
        return f

def revolve_face(face, axis_pnt, axis_dir, angle_deg=360.0):
    # Normalizar axis_dir de forma robusta
    if not isinstance(axis_pnt, App.Vector):
        axis_pnt = App.Vector(axis_pnt)
    axis = App.Vector(axis_dir)
    l = axis.Length
    if l <= TOL:
        raise ValueError("Axis_dir no puede ser nulo.")
    axis = App.Vector(axis.x/l, axis.y/l, axis.z/l)
    try:
        solid = face.revolve(axis_pnt, axis, angle_deg)
        return solid
    except Exception as e:
        b = getattr(face, "BoundBox", None)
        raise RuntimeError("Fallo en revolve (BRep): %s ; Face.BoundBox=%s" % (e, b))

# -----------------------
# Subensambles
# -----------------------

def regular_polygon_wire(n, flat2flat, z0=0.0):
    R = flat2flat / 2.0 / math.cos(math.pi/n)
    pts = []
    for k in range(n):
        ang = 2*math.pi*k/n + math.pi/n
        pts.append(App.Vector(R*math.cos(ang), R*math.sin(ang), z0))
    return make_closed_wire(pts)

def build_hga_dish(diam, depth, thk, hub_r):
    a = diam/2.0
    h = depth
    # proteger contra h == 0
    if h <= 1e-9:
        return Part.makeCylinder(a, thk)
    R = (a*a + h*h) / (2*h)
    cz = h - R
    p_rim_out = App.Vector(a, 0, 0)
    p_tip_out = App.Vector(0, 0, h)
    ang_rim = math.acos(max(min((R - 0)/R, 1.0), -1.0))
    ang_tip = math.acos(max(min((R - h)/R, 1.0), -1.0))
    ang_mid = (ang_rim + ang_tip)/2.0
    x_mid = R*math.sin(ang_mid)
    z_mid = cz + R*math.cos(ang_mid)
    p_mid_out = App.Vector(x_mid, 0, z_mid)
    arc_out = Part.Arc(p_rim_out, p_mid_out, p_tip_out).toShape()
    a_in = max(a - thk, a*0.85)
    h_in = max(h - thk, h*0.85)
    if h_in <= 0:
        h_in = h*0.5
    R_in = (a_in*a_in + h_in*h_in)/(2*h_in)
    cz_in = h_in - R_in
    p_rim_in = App.Vector(a_in, 0, 0)
    p_tip_in = App.Vector(0, 0, h_in)
    ang_rim_in = math.acos(max(min((R_in - 0)/R_in, 1.0), -1.0))
    ang_tip_in = math.acos(max(min((R_in - h_in)/R_in, 1.0), -1.0))
    ang_mid_in = (ang_rim_in + ang_tip_in)/2.0
    x_mid_in = R_in*math.sin(ang_mid_in)
    z_mid_in = cz_in + R_in*math.cos(ang_mid_in)
    p_mid_in = App.Vector(x_mid_in, 0, z_mid_in)
    arc_in = Part.Arc(p_tip_in, p_mid_in, p_rim_in).toShape()
    e_tip = Part.makeLine(p_tip_out, p_tip_in)
    e_rim = Part.makeLine(p_rim_in, p_rim_out)
    w = Part.Wire([arc_out, e_tip, arc_in, e_rim])
    if not w.isClosed():
        pts = [v.Point for v in w.Vertexes]
        w = make_closed_wire(pts)
    f = safe_make_face_from_wire(w)
    try:
        dish_solid = revolve_face(f, App.Vector(0,0,0), App.Vector(0,0,1), 360)
    except Exception as e:
        App.Console.PrintError("Error en revolve HGA: %s\n" % e)
        dish_solid = Part.makeCylinder(a, thk+0.01)
    hub_h = thk*4.0 + 0.05
    try:
        hub = Part.makeCylinder(hub_r, hub_h, App.Vector(0,0, h - hub_h))
        return dish_solid.fuse(hub)
    except Exception:
        return dish_solid

def build_bus_hex(height, flat2flat):
    w = regular_polygon_wire(6, flat2flat, z0=0)
    f = safe_make_face_from_wire(w)
    prism = f.extrude(App.Vector(0,0,height))
    try:
        top_edges = [e for e in prism.Edges if abs(e.BoundBox.ZMax - height) < 1e-6]
        if top_edges:
            ch = prism.makeChamfer(min(0.03, height*0.05), top_edges)
            return ch
        return prism
    except Exception:
        return prism

def build_cyl_tube(radius, length, axis='X'):
    if axis == 'X':
        return Part.makeCylinder(radius, length, App.Vector(0,0,0), App.Vector(1,0,0))
    if axis == 'Y':
        return Part.makeCylinder(radius, length, App.Vector(0,0,0), App.Vector(0,1,0))
    return Part.makeCylinder(radius, length, App.Vector(0,0,0), App.Vector(0,0,1))

def build_rtg(radius, length):
    body = Part.makeCylinder(radius, length, App.Vector(0,0,0), App.Vector(1,0,0))
    cap = Part.makeCone(radius*1.05, radius*0.8, radius*0.25, App.Vector(length,0,0), App.Vector(1,0,0))
    try:
        return body.fuse(cap)
    except Exception:
        return body

def build_lga(diam, depth, thk):
    return build_hga_dish(diam, depth, thk, hub_r=thk*3.0)

def build_huygens(diam, thick_center):
    a = diam/2.0
    if thick_center <= 0:
        raise ValueError("thick_center debe ser > 0")
    h = thick_center/2.0
    # proteger contra valores extremos
    if h <= 1e-6:
        return Part.makeSphere(a*0.5)
    R = (a*a + h*h)/(2*h)
    cz = h - R
    p_rim = App.Vector(a, 0, 0)
    p_top = App.Vector(0, 0, h)
    ang_rim = math.acos(max(min((R - 0)/R, 1.0), -1.0))
    ang_top = math.acos(max(min((R - h)/R, 1.0), -1.0))
    ang_mid = (ang_rim + ang_top)/2.0
    x_mid = R*math.sin(ang_mid)
    z_mid = cz + R*math.cos(ang_mid)
    p_mid_up = App.Vector(x_mid, 0, z_mid)
    cz2 = -h + R
    z_mid2 = cz2 - R*math.cos(ang_mid)
    p_mid_dn = App.Vector(x_mid, 0, z_mid2)
    arc_up = Part.Arc(p_rim, p_mid_up, p_top).toShape()
    arc_dn = Part.Arc(p_top, p_mid_dn, p_rim).toShape()
    w = Part.Wire([arc_up, arc_dn])
    try:
        if not w.isClosed():
            pts = [v.Point for v in w.Vertexes]
            pts_proj = project_points_to_plane(pts, App.Vector(0,0,0), App.Vector(0,1,0))
            pts_proj = unique_points(pts_proj)
            if len(pts_proj) < 3:
                raise ValueError("Perfil Huygens degenerado tras proyección (len=%d)" % len(pts_proj))
            w = make_closed_wire(pts_proj)
        f = safe_make_face_from_wire(w)
        solid = revolve_face(f, App.Vector(0,0,0), App.Vector(0,0,1), 360)
        return solid
    except Exception as e:
        App.Console.PrintError("Fallo al construir Huygens (perfil degenerado). Se crea placeholder esférico: %s\n" % e)
        sph = Part.makeSphere(a*0.5)
        return sph

def place_shape(shape, base, rot_degrees=(0,0,0)):
    rx, ry, rz = rot_degrees
    placement = App.Placement()
    placement.Base = App.Vector(*base)
    rot = App.Rotation(App.Vector(0,0,1), rz).multiply(
          App.Rotation(App.Vector(0,1,0), ry)).multiply(
          App.Rotation(App.Vector(1,0,0), rx))
    placement.Rotation = rot
    moved = shape.copy()
    moved.Placement = placement
    return moved

# -----------------------
# Nuevos componentes espaciales (blindajes, robótica, escudos)
# -----------------------

def build_shield(radius, thickness, height):
    outer = Part.makeCylinder(radius, height)
    inner_r = max(radius - thickness, 0.001)
    inner = Part.makeCylinder(inner_r, height)
    try:
        return outer.cut(inner)
    except Exception:
        return outer

def build_panel(width, height, thick=0.02):
    try:
        # makeBox(x, y, z) -> usar thick como Y para que quede "plano"
        return Part.makeBox(width, thick, height)
    except Exception:
        return Part.makeCylinder(max(width*0.5, 0.001), thick)

def build_robot_arm(length=1.2, radius=0.05):
    base = Part.makeCylinder(radius*1.2, radius*0.4)
    seg1 = Part.makeCylinder(radius, length*0.5)
    seg2 = Part.makeCylinder(radius, length*0.5)
    claw = Part.makeSphere(radius*1.2)
    try:
        arm = base.fuse(seg1.translate(App.Vector(0,0,radius*0.4)))
        arm = arm.fuse(seg2.translate(App.Vector(0,0,length*0.5+radius*0.4)))
        arm = arm.fuse(claw.translate(App.Vector(0,0,length+radius*0.6)))
        return arm
    except Exception:
        return base

def build_thermal_shield(diam, thick):
    try:
        outer = Part.makeSphere(diam/2.0)
        inner = Part.makeSphere(max(diam/2.0 - thick, 0.001))
        return outer.cut(inner)
    except Exception:
        return Part.makeSphere(diam/2.0)

# -----------------------
# Ensamblaje unificado (Cassini + Huygens + extras)
# -----------------------

def build_cassini_huygens(scale=1.0):
    s = scale
    parts = []

    # HGA
    hga = build_hga_dish(HGA_DIAM*s, HGA_DEPTH*s, HGA_THK*s, HGA_HUB_R*s)
    parts.append(("HGA", hga))

    # Bus
    bus = build_bus_hex(BUS_HEIGHT*s, BUS_FLAT2FLAT*s)
    bus_placed = place_shape(bus, base=(0,0, -(BUS_TOP_TO_HGA+BUS_HEIGHT)*s), rot_degrees=(0,0,0))
    parts.append(("BUS", bus_placed))

    # Mástil
    mast = Part.makeCylinder(0.10*s, BUS_TOP_TO_HGA*s, App.Vector(0,0,-BUS_TOP_TO_HGA*s))
    parts.append(("MAST", mast))

    # RTGs/booms (dos lados)
    rtg = build_rtg(RTG_RADIUS*s, RTG_LENGTH*s)
    boom = build_cyl_tube(RTG_BOOM_R*s, RTG_BOOM_LEN*s, axis='X')
    bus_top_z = -(BUS_TOP_TO_HGA)*s
    y_off = (BUS_FLAT2FLAT*0.6)*s
    boom1 = place_shape(boom, base=(0, y_off, bus_top_z + BUS_HEIGHT*0.5*s), rot_degrees=(0,0,0))
    rtg1 = place_shape(rtg, base=(RTG_BOOM_LEN*s, y_off, bus_top_z + BUS_HEIGHT*0.5*s), rot_degrees=(0,0,0))
    boom2 = place_shape(boom, base=(0, -y_off, bus_top_z + BUS_HEIGHT*0.2*s), rot_degrees=(0,180,0))
    rtg2 = place_shape(rtg, base=(RTG_BOOM_LEN*s, -y_off, bus_top_z + BUS_HEIGHT*0.2*s), rot_degrees=(0,180,0))
    parts += [("BOOM1", boom1), ("RTG1", rtg1), ("BOOM2", boom2), ("RTG2", rtg2)]

    # LGA (2)
    lga = build_lga(LGA_DIAM*s, LGA_DEPTH*s, LGA_THK*s)
    lga1 = place_shape(lga, base=(0.7*s, 0.0, -(BUS_TOP_TO_HGA + BUS_HEIGHT*0.6)*s), rot_degrees=(90,0,90))
    lga2 = place_shape(lga, base=(-0.7*s, 0.0, -(BUS_TOP_TO_HGA + BUS_HEIGHT*0.6)*s), rot_degrees=(90,0,-90))
    parts += [("LGA1", lga1), ("LGA2", lga2)]

    # Magnetometer boom
    mag_boom = build_cyl_tube(MAG_BOOM_R*s, MAG_BOOM_LEN*s, axis='Y')
    mag_boom = place_shape(mag_boom, base=(0.0, (BUS_FLAT2FLAT*0.5 + 0.1)*s, -(BUS_TOP_TO_HGA + BUS_HEIGHT*0.2)*s), rot_degrees=(0,0,0))
    parts.append(("MAG_BOOM", mag_boom))

    # Huygens probe
    huy = build_huygens(HUY_DIAM*s, HUY_THK_CENTER*s)
    huy_placed = place_shape(huy, base=(-(BUS_FLAT2FLAT*0.65 + HUY_OFFSET_FROM_BUS)*s, 0, -(BUS_TOP_TO_HGA + BUS_HEIGHT*0.35)*s), rot_degrees=(0,90,0))
    parts.append(("HUYGENS", huy_placed))

    # -----------------------
    # Extras: blindajes, paneles y robótica
    # -----------------------

    # Escudo de radiación alrededor del bus
    shield = build_shield(BUS_FLAT2FLAT*0.7*s, 0.05*s, BUS_HEIGHT*1.2*s)
    shield = place_shape(shield, base=(0,0,-(BUS_TOP_TO_HGA+BUS_HEIGHT)*s*1.05))
    parts.append(("RADIATION_SHIELD", shield))

    # Panel blindado lateral (placeholder)
    panel1 = build_panel(1.5*s, 1.0*s, thick=0.05*s)
    panel1 = place_shape(panel1, base=(BUS_FLAT2FLAT*s, 0, -BUS_HEIGHT*0.5*s))
    parts.append(("PANEL1", panel1))

    # Brazo robótico lateral
    arm = build_robot_arm(length=1.5*s, radius=0.05*s)
    arm = place_shape(arm, base=(0, BUS_FLAT2FLAT*0.8*s, -BUS_HEIGHT*0.3*s), rot_degrees=(0,0,90))
    parts.append(("ROBOT_ARM", arm))

    # Escudo térmico frontal (placeholder)
    thermal = build_thermal_shield(3.5*s, 0.2*s)
    thermal = place_shape(thermal, base=(0,0,(HGA_DEPTH+1.2)*s))
    parts.append(("THERMAL_SHIELD", thermal))

    # Compound final (intento)
    solids = [p for _, p in parts]
    try:
        asm = Part.Compound(solids)
    except Exception as e:
        App.Console.PrintError("No se pudo crear Compound global: %s\n" % e)
        asm = None
    return parts, asm

# -----------------------
# Crear en documento y UI-safe view fit
# -----------------------

def add_obj(shape, name="Part"):
    doc = App.ActiveDocument
    if doc is None:
        doc = ensure_doc()
    try:
        obj = doc.addObject("Part::Feature", name)
        obj.Shape = shape
        return obj
    except Exception as e:
        App.Console.PrintError("Fallo al añadir objeto %s: %s\n" % (name, e))
        return None

def set_color(obj, rgb=(0.8,0.8,0.8), alpha=0.0):
    if not HAS_GUI or obj is None:
        return
    try:
        obj.ViewObject.ShapeColor = rgb
        if alpha > 0:
            obj.ViewObject.Transparency = int(min(max(alpha*100,0), 90))
    except Exception:
        pass

def ensure_doc(name="Cassini_Huygens"):
    if App.ActiveDocument is None or App.ActiveDocument.Name != name:
        for d in list(App.listDocuments().keys()):
            if d == name:
                try:
                    App.closeDocument(d)
                except Exception:
                    pass
        App.newDocument(name)
    return App.ActiveDocument

def main():
    doc = ensure_doc("Cassini_Huygens")
    doc.Label = "Cassini_Huygens"
    parts, asm = build_cassini_huygens(SCALE)
    objects = []
    if DEBUG_SEPARATE:
        for name, shp in parts:
            obj = add_obj(shp, name)
            if obj:
                set_color(obj, rgb=(0.85,0.85,0.85))
                objects.append(obj)
    if asm is not None:
        obj_main = add_obj(asm, "Cassini_Huygens_Assembly")
        if obj_main:
            set_color(obj_main, rgb=(0.9,0.9,0.9))
            objects.append(obj_main)
    doc.recompute()
    if HAS_GUI:
        try:
            Gui.sendMsgToActiveView("ViewFit")
        except Exception:
            try:
                av = Gui.ActiveDocument.ActiveView
                if hasattr(av, "fitAll"):
                    av.fitAll()
            except Exception:
                pass
    App.Console.PrintMessage("Macro finalizado. Revisa la consola para avisos/errores.\n")
    return objects

if __name__ == "__main__":
    main()
